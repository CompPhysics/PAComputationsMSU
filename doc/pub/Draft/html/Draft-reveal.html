<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Computing in Physics courses  at the Physics and Astronomy Department, Michigan State University">

<title>Computing in Physics courses  at the Physics and Astronomy Department, Michigan State University</title>







<!-- reveal.js: http://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .reveal .alert-text-small   { font-size: 80%;  }
    .reveal .alert-text-large   { font-size: 130%; }
    .reveal .alert-text-normal  { font-size: 90%;  }
    .reveal .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
             -webkit-border-radius: 14px; -moz-border-radius: 14px;
             border-radius:14px;
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .reveal .alert-block {padding-top:14px; padding-bottom:14px}
     .reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
     /*.reveal .alert li {margin-top: 1em}*/
     .reveal .alert-block p+p {margin-top:5px}
     /*.reveal .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
     .reveal .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
     .reveal .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
     .reveal .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body>
<div class="reveal">

<!-- Any section element inside the <div class="slides"> container
     is displayed as a slide -->

<div class="slides">



    



<section>
<!-- ------------------- main content ---------------------- -->



<center><h1 style="text-align: center;">Computing in Physics courses  at the Physics and Astronomy Department, Michigan State University</h1></center>  <!-- document title -->

<p>
<!-- author(s): Danny Caballero, Sean Couch, Wade Fisher, Connor Glosser, Morten Hjorth-Jensen, Claire Kopenhafer, Brian O'Shea, and Carlo Piermarocchi -->

<center>
<b>Danny Caballero, Sean Couch, Wade Fisher, Connor Glosser, Morten Hjorth-Jensen, Claire Kopenhafer, Brian O'Shea, and Carlo Piermarocchi</b> 
</center>

<p>&nbsp;<br>
<!-- institution(s) -->

<br>
<p>&nbsp;<br>
<center><h4>Mar 28, 2017</h4></center> <!-- date -->
<br>

<h2 id="___sec0">Introduction: Scientific and educational motivation </h2>

<p>
Numerical simulations of various systems in science are central to our
basic understanding of nature and technology.
The increase in computational power,
improved algorithms for solving problems in science as well as access
to high-performance facilities, allow researchers to study
complicated systems across many length and energy scales. Applications
span from studying quantum physical systems in nanotechnology and the
characteristics of new materials or subatomic physics at its smallest
length scale, to simulating galaxies and the evolution of the universe.
In between, simulations are key to understanding
cancer treatment and how the brain works,
predicting climate changes and this week's weather,
simulating natural disasters, semi-conductor devices,
quantum computers, as well as assessing risk in the insurance and
financial industry.

<h3 id="___sec1">Computing competence </h3>

<p>
Computing means solving scientific problems using computers. It covers
numerical as well as symbolic computing. Computing is also about
developing an understanding of the scientific process by enhancing
algorithmic thinking when solving problems.  Computing competence has
always been a central part of education in the sciences and engineering disciplines.

<p>
On the part of students, this competence involves being able to:

<ul>
<p><li> understand how algorithms are used to solve mathematical problems,</li>
<p><li> derive, verify, and implement algorithms,</li>
<p><li> understand what can go wrong with algorithms,</li>
<p><li> use these algorithms to construct reproducible scientific outcomes and to engage in science in ethical ways, and</li>
<p><li> think algorithmically for the purposes of gaining deeper insights about scientific problems.</li>
</ul>
<p>

All these elements are central for maturing and gaining a better understanding of the modern scientific process per se.

<p>
The power of the scientific method lies in identifying a given problem
as a special case of an abstract class of problems, identifying
general solution methods for this class of problems, and applying a
general method to the specific problem (applying means, in the case of
computing, calculations by pen and paper, symbolic computing, or
numerical computing by ready-made and/or self-written software). This
generic view on problems and methods is particularly important for
understanding how to apply available, generic software to solve a
particular problem.

<p>
Computing competence represents a central element
in scientific problem solving, from basic education and research to
essentially almost all advanced problems in modern
societies. Computing competence is simply central to further
progress. It enlarges the body of tools available to students and
scientists beyond classical tools and allows for a more generic
handling of problems. Focusing on algorithmic aspects results in
deeper insights about scientific problems.

<h3 id="___sec2">Why should basic university education undergo a shift towards modern computing?  </h3>

<ul>
<p><li> Algorithms involving pen and paper are traditionally aimed at what we often refer to as continuous models.</li>
<p><li> Application of computers calls for approximate discrete models.</li>
<p><li> Much of the development of methods for continuous models are now being replaced by methods  for discrete models in science and industry, simply because much larger classes of problems can be addressed with discrete models, often also by simpler and more generic methodologies.</li>
</ul>
<p>

However, verification of algorithms and understanding their limitations requires much of the classical knowledge about continuous models.

<p>
So, why should basic university education undergo a shift towards modern computing?

<p>
The impact of the computer on mathematics and science is tremendous: science and industry now rely on solving mathematical problems through computing.

<ul>
<p><li> Computing can increase the relevance in education by solving more realistic problems earlier.</li>
<p><li> Computing through programming can be excellent training of creativity.</li>
<p><li> Computing can enhance the understanding of abstractions and generalization.</li>
<p><li> Computing can decrease the need for special tricks and tedious algebra, and shifts the focus to problem definition, visualization, and "what if" discussions.</li>
</ul>
<p>

The result is a deeper understanding of mathematical modeling and the scientific method (we hope, and here our physics education research group can play a central role in promoting this).
Not only is computing via programming a very powerful tool, it can also be a great pedagogical aid.

<p>
For the mathematical training, there is one major new component among the arguments above: understanding abstractions and generalization. While many of the classical methods developed for continuous models are specialized for a particular problem or a narrow class of problems, computing-based algorithms are often developed for problems in a generic form and hence applicable to a large problem class.

<p>
Computing competence represents a central element in scientific problem solving, from basic education and research to essentially almost all advanced problems in modern societies. Computing competence is simply central to further progress. It enlarges the body of tools available to students and scientists beyond classical tools and allows for a more generic handling of problems. Focusing on algorithmic aspects results in deeper insights about scientific problems.

<p>
Moreover, today's projects in science and industry tend to involve larger teams. Tools for reliable collaboration must therefore be mastered (e.g., version control systems, automated computer experiments for reproducibility, software and method documentation).

<h2 id="___sec3">General learning outcomes for computing competence </h2>

<p>
Below, we articulate high-level learning outcomes that we expect students to develop through comprehensive and coordinated instruction in numerical methods over the course of their bachelor's program at Michigan State. These learning outcomes are different from specific learning goals in that the former reference the end state that we aim for students to achieve. The latter references the specific knowledge, tools, and practices with which students should engage and discusses how we expect them to participate in that work. We reserve the discussion of specific learning goals to individual course experiences (e.g., Electrostatics).

<h3 id="___sec4">Learning outcomes for numerical algorithms </h3>

<p>
Numerical algorithms form the basis for solving science and engineering problems with computers. An understanding of algorithms does not itself serve as an understanding on computing, but it is a necessary step along the path. Through comprehensive and coordinated instruction, we aim for students to have developed:

<ul>
<p><li> A deep understanding of the most fundamental algorithms for linear algebra, ordinary and partial differential equations, optimization, and statistical uncertainty quantification</li>
<p><li> A working knowledge of advanced algorithms and how they can be accessed in available software</li>
<p><li> A working knowledge of high-performance computing elements including memory usage, vectorized and parallel algorithms</li>
<p><li> A deep understanding of approximation errors and how they can present themselves in different problems</li>
<p><li> The ability to apply fundamental and advanced algorithms to classical model problems as well as real-world problems as well to assess the uncertainty of their results</li>
</ul>

<h3 id="___sec5">Learning outcomes for symbolic computing </h3>

<p>
Symbolic computing is a helpful tool for addressing certain classes of problems where a functional representation of the solution (or part of the solution) is needed. Through engaging with symbolic computing platforms, we aim for students to have developed:

<ul>
<p><li> A working knowledge of at least one computer algebra system (CAS)</li>
<p><li> The ability to apply a CAS to perform classical mathematics including calculus, linear algebra, differential equations</li>
<p><li> The ability to verify the results produced by the CAS using some other means</li>
</ul>

<h3 id="___sec6">Learning outcomes for programming </h3>

<p>
Programming is a necessary aspect of learning computing for science and engineering. The specific languages and/or environments that students learn are less important than the nature of that learning (i.e., learning programming for the purposes of solving science problems). By numerically solving science problems, we expect students to have developed:

<ul>
<p><li> An understanding of programming in a high-level language (e.g., MATLAB, Python, R).</li>
<p><li> An understanding of programming in a compiled language (e.g., Fortran, C, C++).</li>
<p><li> The ability to to implement and apply numerical algorithms in reusable software that acknowledges the generic nature of the mathematical algorithms.</li>
<p><li> A working knowledge of basic software engineering elements including functions, classes, modules/libraries, testing procedures and frameworks, scripting for automated and reproducible experiments, documentation tools, and version control systems (e.g., GitHub).</li>
<p><li> An understanding of debugging software, e.g., as part of implementing comprehensive tests.</li>
</ul>

<h3 id="___sec7">Learning outcomes for mathematical modeling </h3>

<p>
Preparing a problem to be solved numerically (i.e., modeling) is a critical step in making progress towards an eventual solution. By providing opportunities for students engage in modeling, we aim for them to develop:

<ul>
<p><li> The ability to solve real problems from applied sciences by:</li>
<p><li> Deriving computational models from basic principles in physics and articulating the underlying assumptions in those models,</li>
<p><li> Constructing models with dimensionless forms to reduce and simplify input data, and</li>
<p><li> Interpreting the model's dimensionless parameters to increase their understanding of the model and its predictions</li>
</ul>

<h3 id="___sec8">Learning outcomes for verification </h3>

<p>
Verifying the model and the resulting outcomes it produces are essential elements to generating confidence in the model itself. Moreover, such verifications provide evidence that the work is reproducible. By engaging in verification practices, we aim for for students to develop:

<ul>
<p><li> An understanding of how to program testing procedures</li>
<p><li> A deep knowledge of testing/verification methods including the use of:</li>
<p><li> Exact solutions of numerical models</li>
<p><li> Method of manufactured solutions (i.e., choose solution and fit a problem)</li>
<p><li> Classical analytical solutions including asymptotic solutions</li>
<p><li> Computed asymptotic approximation errors (i.e., convergence rates)</li>
<p><li> Step-wise construction of tests to aid debugging.</li>
</ul>

<h3 id="___sec9">Learning outcomes for presentation of results </h3>

<p>
The results of a computation need to be communicated in some format (i.e., through figures, posters, talks, and other forms of written and oral communication). Computation affords the experience of presenting original results quite readily. Through their engagement with presentations for their findings, we aim for students to develop:

<ul>
<p><li> The ability to make use of different visualization techniques for different types of computed data</li>
<p><li> The ability to present computed results in scientific reports and oral presentations effectively</li>
<p><li> A working knowledge of the norms and practices for scientific presentations in various formats (i.e., figures, posters, talks, and written reports)</li>
</ul>

<h2 id="___sec10">Specific algorithms and computational skills </h2>

<p>
The above learning goals and outcomes are of a more generic character. What follows here are specific
algorithms that occur frequently in scientific problems. The implementation of these algorithms in various physics courses, together with problem and project solving, is a way to implement large fractions of the above learning goals. we reserve the coupling of the the broad learning goals above to the algorithms articulated below to our discussion of specific course (or topical) learning goals.

<p>
We list also tools that are important in developing
numerical projects. These tools allow students to develop a better understanding of the scientific process. In addition, use of the algorithms can facilitate instruction in an ethical approach to science.

<p>
The algorithms and tools listed here can be intergated in different ways depending on the specific learning goals for the course or topic. Furthermore, several of these algorithms can be used and, then, revisited in the various courses.

<h3 id="___sec11">Central algorithms </h3>

The following mathematical formulations of problems from the physical sciences play a prominent role and should be reflected in how we teach physics:

<ul>
<p><li> Ordinary differential equations

<ol type="a"></li>

<p><li> Euler, modified Euler, Verlet and Runge-Kutta methods with applications to problems in electromagnetism, methods for theoretical physics, quantum mechanics and mechanics.</li>
</ol>
<p><li> Partial differential equations

<ol type="a"></li>

<p><li> Diffusion in one and two dimensions (statistical physics), wave equation in one and two dimensions (mechanics, electromagnetism, quantum mechanics, methods for theoretical physics) and Laplace's and Poisson's equations (electromagnetism).</li>
</ol>
<p><li> Numerical integration

<ol type="a"></li>

<p><li> Trapezoidal and Simpson's rule and Monte Carlo integration. Applications in statistical physics, methods of theoretical physics, electromagnetism and quantum mechanics.</li>
</ol>
<p><li> Statistical analysis, random numbers, random walks, probability distributions, Monte Carlo integration and Metropolis algorithm. Applications to statistical physics and laboratory courses.</li>
<p><li> Linear Algebra and eigenvalue problems.

<ol type="a"></li>

<p><li> Gaussian elimination, LU-decomposition, eigenvalue solvers, and iterative methods like  Jacobi or Gauss-Seidel for systems of linear equations. Important for several courses, classical mechanics, methods of theoretical physics, electromagnetism and quantum mechanics.</li>
</ol>
<p><li> Signal processing

<ol type="a"></li>

<p><li> Discrete (fast) Fourier transforms, Lagrange/spline/Fourier interpolation, numeric convolutions &amp; circulant matrices, filtering. Applications in electromagnetics, quantum mechanics, and experimental physics (data acquisition)</li>
</ol>
<p><li> Root finding techniques, used in methods for theoretical physics, quantum mechanics, electromagnetism and mechanics.</li>
</ul>
<p>

In order to achieve a proper pedagogical introduction of these algorithms, it is important that students and teachers alike see how these algorithms are used to solve a variety of physics problems. The same algorithm, for example the solution of a second-order differential equation, can be used to solve the equations for the classical pendulum in a mechanics course or the (with a suitable change of variables) equations for a coupled RLC circuit in the electromagnetism course. Similarly, if students develop a program for studies of celestial bodies in the mechanics course, many of the elements of such a program can be reused in a molecular dynamics calculation in a course on statistical physics and thermal physics. The two-point boundary value problem for a buckling beam
(discretized as an eigenvalue problem) can be reused in quantum mechanical studies of interacting electrons in oscillator traps, or just to study a particle in a box potential with varying depth and extension.

<p>
In order to aid the introduction of computational exercises and projects, we will need to develop educational resources for this. The <a href="http://www.compadre.org/picup/" target="_blank">PICUP project</a>,  Partnership for Integration of Computation into Undergraduate Physics, develops <a href="http://www.compadre.org/PICUP/resources/" target="_blank">resources for teachers and students on the integration of computational  material</a>.   We strongly recommend these resources.  Physics is an old discipline, with a large wealth of established analytical exercises and projects. In fields like mechanics, we have centuries of pedagogical developments, with a strong emphasis on developing analytical skills. The majority of physics teachers are well familiar with this and in order to see how computing can enlarge this body of exercises and projects, and hopefully add additional insights to the physics behind various phenomena, we find it important to develop a large body of computational examples.

<p>
As part of this proposal, we are in the process of  developing several examples of problems and projects that can be included in our undergraduate courses in physics. You can click on the following links (ipython notebooks or PDF formats)

<ul>
<p><li> Mechanics

<ol type="a"></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/Mechanics/ipynb" target="_blank">Ipython notebook</a></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/Mechanics/pdf/Mechanics-minted.pdf" target="_blank">Standard PDF file</a></li>
</ol>
<p><li> Quantum mechanics

<ol type="a"></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/Quantum/ipynb" target="_blank">Ipython notebook</a></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/Quantum/pdf/Quantum-minted.pdf" target="_blank">Standard PDF file</a></li>
</ol>
<p><li> Electromagnetism

<ol type="a"></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/Elmag/ipynb" target="_blank">Ipython notebook</a></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/Elmag/pdf/Elmag-minted.pdf" target="_blank">Standard PDF file</a></li>
</ol>
<p><li> Statistical and thermal physics

<ol type="a"></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/StatPhys/ipynb" target="_blank">Ipython notebook</a></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/StatPhys/pdf/StatPhys-minted.pdf" target="_blank">Standard PDF file</a></li>
</ol>
<p><li> Methods in Theoretical Physics (not yet ready)

<ol type="a"></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/" target="_blank">Ipython notebook</a></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/" target="_blank">Standard PDF file</a></li>
</ol>
<p><li> Physics laboratory (not yet ready)

<ol type="a"></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/" target="_blank">Ipython notebook</a></li>

<p><li> <a href="https://github.com/CompPhysics/PAComputationsMSU/tree/master/doc/pub/" target="_blank">Standard PDF file</a></li>
</ol>
<p>
</ul>
<p>

We hope these examples can aid physics teachers in their usage of computing in physics courses. Furthermore, via a consensus and collectively driven approach, the hope is that this body of examples can be continuously enlarged.

<h3 id="___sec12">Central tools and programming languages </h3>

<p>
We will strongly recommend that Python is used as the high-level programming language for all the courses proposed below. Other high-level environments like Mathematica and Matlab can also be presented and offered as special courses like PHY102 - Physics Computations I. This means that students can apply their knowledge from CMSE 201, which makes use of Python, and extend their computational knowledge in various physics classes. We recommend strongly that the following tools are used

<ol>
<p><li> <a href="http://jupyter.org/" target="_blank">Jupyter and ipython notebook</a>.</li>
<p><li> Version control software like <a href="https://git-scm.com/" target="_blank">git</a> and repositories like <a href="https://github.com/" target="_blank">GitHub</a></li>
<p><li> Other typsetting tools like LaTeX.</li>
<p><li> Unit tests and using existing tools for unit tests. <a href="https://docs.python.org/2/library/unittest.html" target="_blank">Python has extensive tools for this</a></li>
</ol>
<p>

The notebooks can be used to hand in exercises and projects. They can provide the students with experience in presenting their work in the form of scientific/technical reports.

<p>
Version control software allows teachers to bring in reproducibility of science as well as enhancing
collaborative efforts among students. Using version control can also be used to help students present benchmark results, allowing others to verify their results.

<p>
Unit testing is a central element in the development of numerical projects, from microtests of code fragments, to intermediate merging of functions to final test of the correctness of a code.

<h2 id="___sec13">Suggested learning goals for specific physics courses </h2>

<p>
For a major in physics degree at Michigan State University, the course <a href="https://cmse.msu.edu/academics/undergraduate-program/undergraduate-courses/cmse-201-introduction-to-computational-modeling/" target="_blank">CMSE 201 Introduction to Computational Modeling</a> is compulsory and it lays the foundation for the use of computational exercises and projects in various physics courses. Based on this course, and the various mathematics courses included in a Physics degree, there is a unique possibility to incorporate computational exercises and projects in various physics courses, without taking away the attention from the basic physics topics to be covered.

<p>
What follows below is a suggested listed of possible learning outcomes. These suggestions are to be viewed as inputs to the ongoing discussions. The list of possible outcomes can be reduced or enlarged.

<p>
<!--  -->
Danny: I have only constructed learning goals for PHY 481. I intend these
to provide a example of what our goals might look like. They are debatable
and not set in stone, but what they do is provide us with a starting point
for discussion and an example of what measurable (i.e., assessable)
learning goals might look like.
<!--  -->

<p>
We propose that the following courses aim to integrate the above learning outcomes and goals:

<h3 id="___sec14">Classical Mechanics 1 PHY321 </h3>

<p>
After completing Classical Mechanics 1 PHY321, students should be able to:

<ul>
<p><li> Represent numbers, complex numbers, vectors, matrices as variables and do simple and appropriate mathematics on these</li>
<p><li> Access constants and physical constants defined in libraries</li>
<p><li> Construct and slice arrays</li>
<p><li> Use functions defined in relevant libraries</li>
<p><li> Write functions to perform specialized tasks</li>
<p><li> determine the root of an algebraic equation numerically using Newton's method</li> 
<p><li> explain Newton's method for finding roots</li>
<p><li> solve a system of algebraic equations using Gaussian elimination numerically</li>
<p><li> explain Gaussian elimination</li> 
<p><li> solve 1st Order, 2nd Order and Coupled ODEs numerically using Euler-Cromer, Verlet, and/or Runge-Kutta algorithms</li> 
<p><li> explain the differences between each of the above algorithms</li> 
<p><li> compare the quality of simulations (i.e., number of iterations, step size, and error control) of particle motion that use different motion prediction algorithms</li>
<p><li> plot solutions</li> 
</ul>

<h3 id="___sec15">Thermal and Statistical Physics PHY410 </h3>

After completing Thermal and Statistical Physics PHY410, students should be able to:

<ul>
<p><li> use central probability distributions and their relation to various expectation values</li>
<p><li> simulate and visualize central probability distributions like the uniform distributions, the exponential distribution and the normal (Gaussian distribution)</li>
<p><li> use concept from statistics to understand central ensembles like the microcanonical and the canonical ensembles</li>
<p><li> simulate Markov processes and understand the links with the process of diffusion (Fick's and Fourier's laws) and the concept of most likely states</li>
<p><li> understand how to simulate stochastic variables using random number generators</li>
<p><li> understand central algorithms like the Metropolis algorithm to simulate systems in statistical physics</li>
<p><li> understand the physics of various phases and phase transitions</li> 
<p><li> study systems like ideal gas and ideal crystals analytically and numerically</li>
<p><li> understand the link between various ensembles; both mathematical and physical links</li>
<p><li> be able to simulate phase transitions via models like the Ising class of models</li>
<p><li> be able to perform molecular dynamics calculations using the velocity Verlet algorithm and simulate phase transitions and visualize and analyze results using realistic interactions.</li>  
</ul>

<h3 id="___sec16">Methods in Theoretical Physics PHY415 </h3>

<p>
After completing Methods in Theoretical Physics PHY415, students should be able to:

<ul>
<p><li> Understand how to discretize differential equations and understand the mathematical truncation errors</li>
<p><li> Understand errors in mathematical algorithms</li>
<p><li> be able to rewrite differential equations using methods from linear algebra</li>
<p><li> know important algorithms for solving eigenvalue problems</li>
<p><li> be able to solve initial value and boundary value problems analytically and numerically</li>
<p><li> know central algorithms for solving eigenvalue problems</li>
<p><li> Solve differential equations numerically and compare with analytical solutions</li>
<p><li> understand  important orthogonal orthogonal polynomials like Legendre, Hermite and Laguerre. Be able to set up their recursion relations and visualize the polynomials.</li> 
<p><li> Understand Fourier transforms and algorithms like Fast Fourier transform</li>
<p><li> Know tools to analyze time series</li>
</ul>
<p>

Many of these algorithms can be discussed and used in the other courses discussed here.

<h3 id="___sec17">Advanced Laboratory course in Physics PHY451 </h3>

After completing Advanced Laboratory course in Physics PHY451, students should be able to:

<ul>
<p><li> read data from CSV files constructed by oscilloscope or LabView program</li>
<p><li> rescale and plot these data</li>
<p><li> smooth, filter, and transform data as needed for specific experiments</li> 
<p><li> compute numerical derivatives or integrals of data as needed for specific experiments</li> 
<p><li> construct a linear fit, fit to exponentials, and a nonlinear fit to a sum of Gaussians or Lorentzians as needed for specific experiments</li>
<p><li> numerically determine location of peaks in data</li>
<p><li> perform a fast Fourier transform and construct a power spectrum of data as needed</li>
<p><li> make histograms from a single column of data</li>
<p><li> calculate mean, standard deviation of data</li>
<p><li> compare histogram to Poisson distribution with the same mean</li>
<p><li> numerically count number of peaks or dips in a spectrum</li>
<p><li> plot data and fits on same figure</li>
<p><li> numerically determine goodness of a fit using residuals</li>
</ul>

<h3 id="___sec18">Quantum mechanics 1  PHY 471 </h3>

<p>
After completing Quantum mechanics 1  PHY 471, students should be able to:

<ul>
<p><li> be able to visualize the solutions of quantum mechanical problems, both stationary and time*dependent problems</li>
<p><li> be able to scale the equations properly and understand the meaning of natural length scales, from the Bohr radius to simple harmonic oscillator problems with frequency dependent length scale. The same scaling procedure is  used to derive the analytical solutions for several single*particle problems.</li> 
<p><li> use numerical methods for solving a large variety of one*dimensional differential equations with two*point boundary value problems. For many cases one can compare directly with standard analytical  solutions like the hydrogen*like problems or the harmonic oscillator.</li>
<p><li> Verification of numerical solutions with analytical results.</li>
<p><li> be able to rewrite Schroedinger's equation as an eigenvalue problem and use numerical eigenvalue methods for computing a single*particle confined in a one*dimensional infinite potential and compare with analytical results. This problem is the same as the eigenvalue problem of a buckling beam, which can be used the in the mechanics and mathematical methods course.</li> 
<p><li> use the the same eigenvalue solvers to study a single particle confined to move in a potential well with a finite depth and extension. Study both bound and unbound states and explore the numerical solutions as functions of the potential depth and the extension of the potential.</li> 
<p><li> The same codes can be used to solve the hydrogen atom and the one*dimensional harmonic oscillator. This part allows for comparison with analytical results.</li> 
<p><li> Visualize the probability distributions for electrons (or other one*particle problems) confined to move in hydrogen*like and harmonic oscillator like problems. Study the probability distributions for ground and excited states. Discuss unbound states with a finite potential well.</li>
<p><li> Use the same codes to study double*well potentials. These are problems of great interest in solid state physics.</li>
<p><li> Rewrite a two*electron (or two*particle problem) problem in terms of the relative and center*of*mass motion and study the role of repulsive Coulomb forces) for electrons (or other fermions) trapped</li> 
<p><li> Visualize and compute tunneling phenomena for various potentials.</li>
<p><li> Introduce the  variational principle and introduce variational Monte Carlo methods to study one*particle problems and compare these with analytical results and numerical results from differental equation solvers.  The Metropolis algorithm discussed in Statistical physics can be reused here. Gives the students a further understanding of statistics related topics, including random number generators, probability distributions, mean values and standard deviations. These issues would also be discussed in PHY415. The students will then see central algorithms being used in different physics settings.</li>
</ul>
<p>

Many of these topics can be included and extended upon in PHY472.

<h3 id="___sec19">Electromagnetism 1 PHY481 </h3>

<p>
After completing Electromagnetism 1 PHY481, students should be able to:

<ul>
<p><li> use symbolic computing tools to determine the gradient of various scalar fields</li>
<p><li> use symbolic computing to determine the divergence and curl of various vector fields</li>
<p><li> represent the vector (e.g., electric) field visually using vector plots and stream plots</li>
<p><li> represent a 2D scalar (i.e., potential) field visually using 2D contour plots and 3D surface plots</li>
<p><li> apply motion prediction algorithms Euler, Verlet, and Runge*Kutta to model the motion of charged particles in electric and magnetic fields</li>
<p><li> compare the quality of simulations (i.e., number of iterations, step size, and error control) of charged particle motion that use different motion prediction algorithms</li>
<p><li> apply Coulomb's law iteratively to determine the electric field produced by a given charge distribution</li>
<p><li> apply Biot*Savart's law iteratively to determine the magnetic field produced by a given current distribution</li>
<p><li> explain how the application of superposition iteratively gives rise to approximate field solutions</li>
<p><li> explain how the simple relaxation algorithm works (i.e., iteratively averaging neighboring points) and how it is derived from the properties of the solutions to Laplace's equation</li>
<p><li> apply this simple relaxation method to find the potential for 1D and 2D electrostatic situations where Laplace's equation is satisfied</li>
<p><li> explain how to use the finite*differencing to recast Poisson's equation into a discrete formulation and how the resulting discretized form compares with the simple relaxation method (i.e., iteratively averaging neighboring points)</li>
<p><li> apply the Jacobi and Gauss*Seidel methods to solve 2D Laplace and Poisson problems including graphing the results in three dimensions</li>
<p><li> explain the differences between the Jacobi and Gauss*Seidel methods and how these methods are connected to the derivation using finite differencing</li>
<p><li> Compare the quality of the simulations (i.e., number of iterations, step size, and error control) that employ the Jacobi method and the Gauss*Seidel method</li>
<p><li> See <a href="https://dannycab.github.io/phy481msu/learning_goals.html" target="_blank">the detailed learning outcomes for PHY 481</a> for more information.</li>
</ul>
<p>

Many of these topics can be included and extended upon in PHY482.

<p>
<!--  -->
Danny: I haven't yet reviewed the material below in detail because I wanted
us to spend time discussing the learning outcomes. These learning outcomes
are connected to the work that the Physics Education Research Lab would do
as we help to develop assessments and evaluations to share with the faculty
<!--  -->

<h2 id="___sec20">Physics Education research and computing in science education </h2>

<p>
The introduction of computational elements in the various courses should be stronly integrated with ongoing research on physics education.

<p>
The Physics and Astronomy department at MSU is in a unique position due to its strong research group in physics education, the <a href="http://www.pa.msu.edu/research/physics*education*lab" target="_blank">PERL group</a>.
This means that it is possible to
develop research motivated curricular changes.  There are many interesting challenges here, like
which are the main obstacles when transferring from a classical pen and paper approach to actually have a working program which solves the same (and more general problems). What is a good progression in presenting numerical topics in physics courses? Are there specific mathematical skills we would like our students to have? How do we integrate student*active teaching, how do we develop and test various assessment methods?

<h2 id="___sec21">Advanced computational physics courses </h2>

<p>
Towards the end of undergraduate studies it is useful to offer a course which focuses on more advanced algorithms and presents compiled languages like C++ and Fortran, languages our students will meet in actual research.
Furthemore, such a course, like the present <a href="https://github.com/CompPhysics/ComputationalPhysicsMSU" target="_blank">PHY480 Computational Physics</a> offers as well more advanced projects which train the students in actual research, developing more complicated programs and working on larger projects.
The  course could cover

<ul>
<p><li> C++ and/or Fortran programming</li>
<p><li> Numerical derivation and integration</li>
<p><li> Random numbers and Monte Carlo integration</li>
<p><li> Monte Carlo methods in statistical physics</li>
<p><li> Quantum Monte Carlo methods</li>
<p><li> Linear algebra and eigenvalue problems</li>
<p><li> Non*linear equations and roots of polynomials</li>
<p><li> Ordinary differential equations</li>
<p><li> Partial differential equations</li>
<p><li> Parallelization of codes</li>
<p><li> High*performance computing aspects and optimization of codes</li>
</ul>
<p>

During the last years, we have witnessed an enhanced background in computing and programming skills among our students. Our students will however always form a heteregeneous group, with often differing competences, experiences and interests. In order to be able to offer a wider spectrum of computational physics courses, the present working group would like to propose courses that can be used in both a major in computational physics, or a Master of Science in computational physics, or a dual degree from the Physics and Astronomy department and the new Computational Mathematics, Science and Engineering (CMSE) department, or just satisfy the scientific interests of our students

<p>
In addition to PHY480, we may
consider more advanced (at the graduate level) courses which cover specialized topics.
These could be (presently some of these topics  are covered by PHY905, sections 002 and 003)

<ol>

<p><li> Computational quantum mechanics, spanning from Monte Carlo methods to other methods used in atomic, molecular, nuclear, condensed matter and high*energy physics</li>

<p><li> Computational Statistical mechanics, covering topics spanning from Molecular dynamics to studies of phase transitions, highly relevant for several subdisciplines</li>

<p><li> Computational Astrophysics and Astronomy</li>

<p><li> Data analysis and machine learning tailored to physics problems. This course can be jointly taught with the new department of Computational Science.</li>

<p><li> Additional CMSE courses, see list below.</li>
</ol>
<p>

The CMSE department offers in addition a series <a href="https://cmse.msu.edu/academics/" target="_blank">of courses at all levels</a>.

<h2 id="___sec22">A possible Physics major in computational physics and a possible MSc in Computational Physics </h2>

<p>
The above advanced courses can form the basis for a MSc in computational physics, as well as, together with 
CSME courses, a major in computational physics.

<p>
The following is a suggestion for a major in Computational physics and a Master of Science degree in Computational Physics.

<h3 id="___sec23">Master of Science in Computational Physics </h3>

<p>
The Master of Science in Computational Physics has a duration of two years, with three semesters  of course work and one semester of thesis work. (discuss whether we should have the flexibility of two semesters of course work and two semesters of thesis work).

<ol>
<p><li> The thesis work is to be conducted with one or more research groups at the Department of Physics and Astronomy. It can also be of a more interdisciplinary character and can be a joint thesis with another department at the College of Natural Science and College of Engineering.</li> 
<p><li> Core physics courses (these courses should be compulsory)</li> 
<p><li> PHY 810 * Methods of Theoretical Physics, 3 credits, fall semester</li>
<p><li> PHY 820 * Classical Mechanics, 3 credits, fall semester</li> 
<p><li> PHY 851 * Quantum Mechanics I, 3 credits, fall semester</li> 
<p><li> PHY 841 * Classical Electrodynamics I, 3 credits, spring semester</li> 
<p><li> PHY 831 * Statistical Mechanics, 3 credits, fall semester</li>
<p><li> Computational Science and Physics courses, select in order to fill up necessary credit requirements.</li>

<ul>
 <p><li> Computational quantum mechanics, spanning from Monte Carlo methods to other methods used in atomic, molecular, nuclear, condensed matter and high*energy physics</li>
 <p><li> Computational Statistical mechanics, covering topics spanning from Molecular dynamics to studies of phase transitions, highly relevant for several subdisciplines</li>
 <p><li> Computational Astrophysics and Astronomy</li>
 <p><li> Data analysis and machine learning tailored to physics problems. This course can be jointly taught with the new department of Computational Science.</li>
 <p><li> CMSE 802, Methods in Computational Modeling, 3 credits, spring and fall semesters</li>
 <p><li> CMSE 820, Mathematical Foundations of Data Science, 3 credits, spring semester</li>
 <p><li> CMSE 821, Numerical Methods for Differential Equations, 3 credits, spring semester</li>
 <p><li> CMSE/CSE 822, Parallel Computing, 3 credits, fall semester</li>
 <p><li> CMSE 823, Numerical Linear Algebra, I, 3 credits, fall semester</li>
</ul>
<p>
</ol>

<h3 id="___sec24">Major of Science in Computational Physics </h3>

<p>
The major of science in Computational Physics replaces all physics laboratory courses with either Computational physics courses and/or CMSE courses. Need more input here.

<h2 id="___sec25">Links with CMSE and Mathematics courses </h2>

<p>
We would like to propose to establish a working group which studies an eventual  integration and possibly coordination of many of the 
abovementioned algorithms in the mathematics courses our physics students take. For example, algorithms from linear algebra play a central role, and with CS201 as background, there is a unique opportunity to enlarge the body of mathematical examples with numerical tools and algorithms. The most likely scenario in the next five to ten years is that our students will be better educated in programming and computations. This should ease the introduction of numerical algorithms and exercises in many of the basic mathematics courses.

<p>
With such a background, it is easier for physics teachers, with proper repetitions and adequate material, to introduce numerical exercises and projects in many basic physics courses.
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

    // Display navigation controls in the bottom right corner
    controls: true,

    // Display progress bar (below the horiz. slider)
    progress: true,

    // Display the page number of the current slide
    slideNumber: true,

    // Push each slide change to the browser history
    history: false,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    //center: true,
    center: false,

    // Enables touch navigation on devices with touch input
    touch: true,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Turns fragments on and off globally
    fragments: true,

    // Flags if the presentation is running in an embedded mode,
    // i.e. contained within a limited portion of the screen
    embedded: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Stop auto-sliding after user input
    autoSlideStoppable: true,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Hides the address bar on mobile devices
    hideAddressBar: true,

    // Opens links in an iframe preview overlay
    previewLinks: false,

    // Transition style
    transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

    // Transition speed
    transitionSpeed: 'default', // default/fast/slow

    // Transition style for full page slide backgrounds
    backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

    // Number of slides away from the current that are visible
    viewDistance: 3,

    // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

    // Parallax background size
    //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

    theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interpret Markdown in <section> elements
        { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

        // Syntax highlight for <code> elements
        { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Zoom in and out with Alt+click
        { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speaker notes
        { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remote control your reveal.js presentation using a touch device
        //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

        // MathJax
        //{ src: 'reveal.js/plugin/math/math.js', async: true }
    ]
});

Reveal.initialize({

    // The "normal" size of the presentation, aspect ratio will be preserved
    // when the presentation is scaled to fit different resolutions. Can be
    // specified using percentage units.
    width: 1170,  // original: 960,
    height: 700,

    // Factor of the display size that should remain empty around the content
    margin: 0.1,

    // Bounds for smallest/largest possible scale to apply to content
    minScale: 0.2,
    maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
     end footer logo -->



</body>
</html>
