TITLE: Computing in Physics courses  at the Physics and Astronomy Department, Michigan State University
AUTHOR: Danny Caballero, Sean Couch, Wade Fisher, Connor Glosser, Nat Hawkins, Morten Hjorth-Jensen, Claire Kopenhafer, Brian O'Shea, and Carlo Piermarocchi
DATE: today


===== Introduction: Scientific and educational motivation =====

Numerical simulations of various systems in science are central to our
basic understanding of nature and technology.
The increase in computational power,
improved algorithms for solving problems in science, as well as access
to high-performance facilities, allow researchers to study
complicated systems across many length and energy scales. Applications
span from studying quantum physical systems in nanotechnology and the
characteristics of new materials or subatomic physics at its smallest
length scale, to simulating galaxies and the evolution of the universe.
In between, simulations are key to understanding
cancer treatment and how the brain works,
predicting climate changes and this week's weather,
simulating natural disasters, semi-conductor devices,
quantum computers, as well as assessing risk in the insurance and
financial industry.


=== Computing competence ===

Computing means solving scientific problems using computers. It covers
numerical as well as symbolic computing. Computing is also about
developing an understanding of the scientific process by enhancing
algorithmic thinking when solving problems.  Computing competence has
always been a central part of education in the sciences and engineering disciplines.

On the part of students, this competence involves being able to:

* understand how algorithms are used to solve mathematical problems,
* derive, verify and implement algorithms,
* understand what can go wrong with algorithms,
* use these algorithms to construct reproducible scientific outcomes and to engage in science in ethical ways, and
* think algorithmically for the purposes of gaining deeper insights about scientific problems.

All these elements are central for maturing and gaining a better understanding of the scientific process.

The power of the scientific method lies in identifying a given problem
as a special case of an abstract class of problems, identifying
general solution methods for this class of problems, and applying a
general method to the specific problem (applying means, in the case of
computing, calculations by pen and paper, symbolic computing, or
numerical computing by ready-made and/or self-written software). This
generic view on problems and methods is particularly important for
understanding how to apply available, generic software to solve a
particular problem.

Computing competence represents a central element
in scientific problem solving, from basic education and research to
essentially almost all advanced problems in modern
societies. Computing competence is central to further
progress. It enlarges the body of tools available to students and
scientists beyond classical tools and allows for a more generic
handling of problems. Focusing on algorithmic aspects results in
deeper insights about scientific problems.





=== Why should basic university education undergo a shift towards modern computing?  ===

* Algorithms involving pen and paper are traditionally aimed at what we often refer to as continuous models.
* Application of computers calls for approximate discrete models.
* Much of the development of methods for continuous models are now being replaced by methods  for discrete models in science and industry, simply because much larger classes of problems can be addressed with discrete models, often also by simpler and more generic methodologies.

However, verification of algorithms and understanding their limitations requires much of the classical knowledge about continuous models.

So, why should basic university education undergo a shift towards modern computing?

The impact of the computer on mathematics and science is tremendous: science and industry now rely on solving mathematical problems through computing.
* Computing can increase the relevance in education by solving more realistic problems earlier.
* Computing through programming can be excellent training of creativity.
* Computing can enhance the understanding of abstractions and generalization.
* Computing can decrease the need for special tricks and tedious algebra, and shifts the focus to problem definition, visualization, and "what if" discussions.


The result is a deeper understanding of mathematical modeling and the scientific method.
Not only is computing via programming a very powerful tool, it can also be a great pedagogical aid.

For the mathematical training, there is one major new component among the arguments above: understanding abstractions and generalization. While many of the classical methods developed for continuous models are specialized for a particular problem or a narrow class of problems, computing-based algorithms are often developed for problems in a generic form and hence applicable to a large problem class, with the possible benefits of making additional abstractions.


Computing competence represents a central element in scientific problem solving, from basic education and research to essentially almost all advanced problems in modern societies. It enlarges the body of tools available to students and scientists beyond classical tools and allows for a more generic handling of problems. Focusing on algorithmic aspects results in deeper insights about scientific problems.

Moreover, today's projects in science and industry tend to involve larger teams. Tools for reliable collaboration must therefore be mastered (e.g., version control systems, automated computer experiments for reproducibility, software and method documentation).


===== General learning outcomes for computing competence =====

Below, we articulate high-level learning outcomes that we expect students to develop through comprehensive and coordinated instruction in numerical methods over the course of their bachelor's program at Michigan State. These learning outcomes are different from specific learning goals in that the former reference the end state that we aim for students to achieve. The latter references the specific knowledge, tools, and practices with which students should engage and discusses how we expect them to participate in that work. We reserve the discussion of specific learning goals to individual course experiences (see below).

=== Learning outcomes for numerical algorithms ===

Numerical algorithms form the basis for solving science and engineering problems with computers. An understanding of algorithms does not itself serve as an understanding on computing, but it is a necessary step along the path. Through comprehensive and coordinated instruction, we aim for students to have developed:

* A deep understanding of the most fundamental algorithms for linear algebra, ordinary and partial differential equations, optimization, and statistical uncertainty quantification
* A working knowledge of advanced algorithms and how they can be accessed in available software
* A working knowledge of high-performance computing elements including memory usage, vectorized and parallel algorithms
* A deep understanding of approximation errors and how they can present themselves in different problems
* The ability to apply fundamental and advanced algorithms to classical model problems as well as real-world problems as well to assess the uncertainty of their results

=== Learning outcomes for symbolic computing ===

Symbolic computing is a helpful tool for addressing certain classes of problems where a functional representation of the solution (or part of the solution) is needed. Through engaging with symbolic computing platforms, we aim for students to have developed (not all):

* A working knowledge of at least one computer algebra system (CAS)
* The ability to apply a CAS to perform classical mathematics including calculus, linear algebra anddifferential equations
* The ability to verify the results produced by the CAS using some other means

=== Learning outcomes for programming ===

Programming is a necessary aspect of learning computing for science and engineering. The specific languages and/or environments that students learn are less important than the nature of that learning (i.e., learning programming for the purposes of solving science problems). By numerically solving science problems, we expect students to have developed:

* An understanding of programming in a high-level language (e.g., MATLAB, Python, R).
* An understanding of programming in a compiled language (e.g., Fortran, C, C++).
* The ability to to implement and apply numerical algorithms in reusable software that acknowledges the generic nature of the mathematical algorithms.
* A working knowledge of basic software engineering elements including functions, classes, modules/libraries, testing procedures and frameworks, scripting for automated and reproducible experiments, documentation tools, and version control systems (e.g., Git).
* An understanding of debugging software, e.g., as part of implementing comprehensive tests.

=== Learning outcomes for mathematical modeling ===

Preparing a problem to be solved numerically (i.e., modeling) is a critical step in making progress towards an eventual solution. By providing opportunities for students engage in modeling, we aim for them to developt he ability to solve real problems from applied sciences by:

* Deriving computational models from basic principles in physics and articulating the underlying assumptions in those models,
* Constructing models with dimensionless forms to reduce and simplify input data, and
* Interpreting the model's dimensionless parameters to increase their understanding of the model and its predictions

=== Learning outcomes for verification ===

Verifying a model and the resulting outcomes it produces are essential elements to generating confidence in the model itself. Moreover, such verifications provide evidence that the work is reproducible. By engaging in verification practices, we aim for for students to develop:

* An understanding of how to program testing procedures
* A deep knowledge of testing/verification methods including the use of:
* Exact solutions of numerical models
* Method of manufactured solutions (i.e., choose solution and fit a problem)
* Classical analytical solutions including asymptotic solutions
* Computed asymptotic approximation errors (i.e., convergence rates)
* Step-wise construction of tests to aid debugging.

=== Learning outcomes for presentation of results ===

The results of a computation need to be communicated in some format (i.e., through figures, posters, talks, and other forms of written and oral communication). Computation affords the experience of presenting original results quite readily. Through their engagement with presentations for their findings, we aim for students to develop:

* The ability to make use of different visualization techniques for different types of computed data
* The ability to present computed results in scientific reports and oral presentations effectively
* A working knowledge of the norms and practices for scientific presentations in various formats (i.e., figures, posters, talks, and written reports)


=====  Specific algorithms and computational skills =====

The above learning goals and outcomes are of a more generic character. What follows here are specific
algorithms that occur frequently in scientific problems. The implementation of these algorithms in various physics courses, together with problem and project solving, is a way to implement large fractions of the above learning goals. we reserve the coupling of the broad learning goals above to the algorithms articulated below to our discussion of specific course (or topical) learning goals.

We list as well tools that are important in developing
numerical projects. These tools allow students to develop a better understanding of the scientific process. In addition, use of the algorithms can facilitate instruction in an ethical approach to science.

The algorithms and tools listed here can be intergated in different ways depending on the specific learning goals for the course or topic. Furthermore, several of these algorithms can be used and, then, revisited in the various courses, see the examples at the end of this document.

=== Central algorithms ===

The following mathematical formulations of problems from the physical sciences play a prominent role and should be reflected in how we teach physics:
* Ordinary differential equations
   o Euler, modified Euler, Verlet and Runge-Kutta methods with applications to problems in electromagnetism, methods for theoretical physics, quantum mechanics and mechanics.
* Partial differential equations
   o Diffusion in one and two dimensions (statistical physics), wave equation in one and two dimensions (mechanics, electromagnetism, quantum mechanics, methods for theoretical physics) and Laplace's and Poisson's equations (electromagnetism).
* Numerical integration
   o Trapezoidal and Simpson's rule and Monte Carlo integration. Applications in statistical physics, methods of theoretical physics, electromagnetism and quantum mechanics.
* Statistical analysis, random numbers, random walks, probability distributions, Monte Carlo integration and Metropolis algorithm. Applications to statistical physics and laboratory courses.
* Linear Algebra and eigenvalue problems.
   o Gaussian elimination, LU-decomposition, eigenvalue solvers, and iterative methods like  Jacobi or Gauss-Seidel for systems of linear equations. Important for several courses, classical mechanics, methods of theoretical physics, electromagnetism and quantum mechanics.
* Signal processing
   o Discrete (fast) Fourier transforms, Lagrange/spline/Fourier interpolation, numeric convolutions & circulant matrices, filtering. Applications in electromagnetics, quantum mechanics, and experimental physics (data acquisition)
* Root finding techniques, used in methods for theoretical physics, quantum mechanics, electromagnetism and mechanics.

In order to achieve a proper pedagogical introduction of these algorithms, it is important that students and teachers alike see how these algorithms are used to solve a variety of physics problems. The same algorithm, for example the solution of a second-order differential equation, can be used to solve the equations for the classical pendulum in a mechanics course or the (with a suitable change of variables) equations for a coupled RLC circuit in the electromagnetism course. Similarly, if students develop a program for studies of celestial bodies in the mechanics course, many of the elements of such a program can be reused in a molecular dynamics calculation in a course on statistical physics and thermal physics. The two-point boundary value problem for a buckling beam
(discretized as an eigenvalue problem) can be reused in quantum mechanical studies of interacting electrons in oscillator traps, or just to study a particle in a box potential with varying depth and extension. The examples at the end of this document provide further examples.

In order to aid the introduction of computational exercises and projects, we will need to develop educational resources for this. The "PICUP project":"http://www.compadre.org/picup/",  Partnership for Integration of Computation into Undergraduate Physics, develops "resources for teachers and students on the integration of computational  material":"http://www.compadre.org/PICUP/resources/".   We strongly recommend these resources.  Physics is an old discipline, with a large wealth of established analytical exercises and projects. In fields like mechanics, we have centuries of pedagogical developments, with a strong emphasis on developing analytical skills. The majority of physics teachers are well familiar with this and in order to see how computing can enlarge this body of exercises and projects, and hopefully add additional insights to the physics behind various phenomena, we find it important to develop a large body of computational examples.

=== Central tools and programming languages ===

We will strongly recommend that Python is used as the high-level programming language for all the courses proposed below. Other high-level environments like Mathematica and Matlab can also be presented and offered as special courses like PHY102 - Physics Computations I. This means that students can apply their knowledge from CMSE 201, which makes use of Python, and extend their computational knowledge in various physics classes. We recommend strongly that the following tools are used
 o "Jupyter and ipython notebook":"http://jupyter.org/".
 o Version control software like "git":"https://git-scm.com/" and repositories like "GitHub":"https://github.com/"
 o Other typsetting tools like LaTeX.
 o Unit tests and using existing tools for unit tests. "Python has extensive tools for this":"https://docs.python.org/2/library/unittest.html"

The notebooks can be used to hand in exercises and projects. They can provide the students with experience in presenting their work in the form of scientific/technical reports.

Version control software allows teachers to bring in reproducibility of science as well as enhancing
collaborative efforts among students. Using version control can also be used to help students present benchmark results, allowing others to verify their results.

Unit testing is a central element in the development of numerical projects, from microtests of code fragments, to intermediate merging of functions to final test of the correctness of a code.

=====  Suggested learning goals and computational topics for specific physics courses =====

For a major in physics degree at Michigan State University, the course "CMSE 201 Introduction to Computational Modeling":"https://cmse.msu.edu/academics/undergraduate-program/undergraduate-courses/cmse-201-introduction-to-computational-modeling/" is compulsory and it lays the foundation for the use of computational exercises and projects in various physics courses. Based on this course, and the various mathematics courses included in a Physics degree, there is a unique possibility to incorporate computational exercises and projects in various physics courses, without taking away the attention from the basic physics topics to be covered.

What follows below is a suggested list of possible learning outcomes. _These suggestions are to be viewed as inputs to the ongoing discussions. The list of possible outcomes can be reduced or enlarged_.
The hope is that the various points listed here can serve as a good starting point for future discussions and developments. 

In order to get the discussion started, 
we propose that the following courses aim to integrate the above learning outcomes and goals:


=== Classical Mechanics 1 PHY321 ===

After completing Classical Mechanics 1 PHY321, students should be able to:
* Represent numbers, complex numbers, vectors, matrices as variables and do simple and appropriate mathematics on these
* Access constants and physical constants defined in libraries
* Construct and slice arrays
* Use functions defined in relevant libraries
* Write functions to perform specialized tasks
* determine the root of an algebraic equation numerically using Newton's method
* explain Newton's method for finding roots
* solve a system of algebraic equations using Gaussian elimination numerically
* explain Gaussian elimination
* solve 1st Order, 2nd Order and Coupled ODEs numerically using Euler-Cromer, Verlet, and/or Runge-Kutta algorithms
* explain the differences between each of the above algorithms
* compare the quality of simulations (i.e., number of iterations, step size, and error control) of particle motion that use different motion prediction algorithms
* plot solutions

=== Thermal and Statistical Physics PHY410 ===
After completing Thermal and Statistical Physics PHY410, students should be able to:
* use central probability distributions and their relation to various expectation values
* simulate and visualize central probability distributions like the uniform distributions, the exponential distribution and the normal (Gaussian distribution)
* use concept from statistics to understand central ensembles like the microcanonical and the canonical ensembles
* simulate Markov processes and understand the links with the process of diffusion (Fick's and Fourier's laws) and the concept of most likely states
* understand how to simulate stochastic variables using random number generators
* understand central algorithms like the Metropolis algorithm to simulate systems in statistical physics
* understand the physics of various phases and phase transitions
* study systems like ideal gas and ideal crystals analytically and numerically
* understand the link between various ensembles; both mathematical and physical links
* be able to simulate phase transitions via models like the Ising class of models
* be able to perform molecular dynamics calculations using the velocity Verlet algorithm and simulate phase transitions and visualize and analyze results using realistic interactions.


=== Methods in Theoretical Physics PHY415 ===

After completing Methods in Theoretical Physics PHY415, students should be able to:
* Understand how to discretize differential equations and understand the mathematical truncation errors
* Understand errors in mathematical algorithms
* be able to rewrite differential equations using methods from linear algebra
* know important algorithms for solving eigenvalue problems
* be able to solve initial value and boundary value problems analytically and numerically
* know central algorithms for solving eigenvalue problems
* Solve differential equations numerically and compare with analytical solutions
* understand  important orthogonal polynomials like Legendre, Hermite and Laguerre. Be able to set up their recursion relations and visualize the polynomials.
* Understand Fourier transforms and algorithms like Fast Fourier transform
* Know tools to analyze time series


Many of these algorithms can be discussed and used in the other courses discussed here.

=== Advanced Laboratory course in Physics PHY451 ===
After completing Advanced Laboratory course in Physics PHY451, students should be able to:

* read data from CSV files constructed by oscilloscope or LabView program
* rescale and plot these data
* smooth, filter, and transform data as needed for specific experiments
* compute numerical derivatives or integrals of data as needed for specific experiments
* construct a linear fit, fit to exponentials, and a nonlinear fit to a sum of Gaussians or Lorentzians as needed for specific experiments
* numerically determine location of peaks in data
* perform a fast Fourier transform and construct a power spectrum of data as needed
* make histograms from a single column of data
* calculate mean, standard deviation of data
* compare histogram to Poisson distribution with the same mean
* numerically count number of peaks or dips in a spectrum
* plot data and fits on same figure
* numerically determine goodness of a fit using residuals
* propagating uncertainty when combining fit parameters using the covariance matrix

=== Quantum mechanics 1  PHY 471 ===

After completing Quantum mechanics 1  PHY 471, students should be able to:
* be able to visualize the solutions of quantum mechanical problems, both stationary and time-dependent problems
* be able to scale the equations properly and understand the meaning of natural length scales, from the Bohr radius to simple harmonic oscillator problems with frequency dependent length scale. The same scaling procedure is  used to derive the analytical solutions for several single-particle problems.
* use numerical methods for solving a large variety of one-dimensional differential equations with two-point boundary value problems. For many cases one can compare directly with standard analytical  solutions like the hydrogen-like problems or the harmonic oscillator.
* Verification of numerical solutions with analytical results.
* be able to rewrite Schroedinger's equation as an eigenvalue problem and use numerical eigenvalue methods for computing a single particle confined in a one-dimensional infinite potential and compare with analytical results. This problem is the same as the eigenvalue problem of a buckling beam, which can be used the in the mechanics and mathematical methods course.
* use the the same eigenvalue solvers to study a single particle confined to move in a potential well with a finite depth and extension. Study both bound and unbound states and explore the numerical solutions as functions of the potential depth and the extension of the potential.
* The same codes can be used to solve the hydrogen atom and the one-dimensional harmonic oscillator. This part allows for comparison with analytical results.
* Visualize the probability distributions for electrons (or other one-particle problems) confined to move in hydrogen*like and harmonic oscillator like problems. Study the probability distributions for ground and excited states. Discuss unbound states with a finite potential well.
* Use the same codes to study double well potentials. These are problems of great interest in solid state physics.
* Rewrite a two-electron (or two-particle problem) problem in terms of the relative and center-of-mass motion and study the role of repulsive Coulomb forces) for electrons (or other fermions) trapped
* Visualize and compute tunneling phenomena for various potentials.
* Introduce the  variational principle and introduce variational Monte Carlo methods to study one-particle problems and compare these with analytical results and numerical results from differental equation solvers.  The Metropolis algorithm discussed in Statistical physics can be reused here. Gives the students a further understanding of statistics related topics, including random number generators, probability distributions, mean values and standard deviations. These topics could also be discussed in PHY415. The students will then see central algorithms being used in different physics settings.


Many of these topics can be included and extended upon in PHY472.
=== Electromagnetism 1 PHY481 ===

After completing Electromagnetism 1 PHY481, students should be able to:
* use symbolic computing tools to determine the gradient of various scalar fields
* use symbolic computing to determine the divergence and curl of various vector fields
* represent the vector (e.g., electric) field visually using vector plots and stream plots
* represent a 2D scalar (i.e., potential) field visually using 2D contour plots and 3D surface plots
* apply motion prediction algorithms Euler, Verlet, and Runge-Kutta to model the motion of charged particles in electric and magnetic fields
* compare the quality of simulations (i.e., number of iterations, step size, and error control) of charged particle motion that use different motion prediction algorithms
* apply Coulomb's law iteratively to determine the electric field produced by a given charge distribution
* apply Biot-Savart's law iteratively to determine the magnetic field produced by a given current distribution
* explain how the application of superposition iteratively gives rise to approximate field solutions
* explain how the simple relaxation algorithm works (i.e., iteratively averaging neighboring points) and how it is derived from the properties of the solutions to Laplace's equation
* apply this simple relaxation method to find the potential for 1D and 2D electrostatic situations where Laplace's equation is satisfied
* explain how to use  finite-difference methods to recast Poisson's equation into a discrete formulation and how the resulting discretized form compares with the simple relaxation method (i.e., iteratively averaging neighboring points)
* apply the Jacobi and Gauss-Seidel methods to solve 2D Laplace and Poisson problems including graphing the results in three dimensions
* explain the differences between the Jacobi and Gauss-Seidel methods and how these methods are connected to the derivation using finite differencing
* Compare the quality of the simulations (i.e., number of iterations, step size, and error control) that employ the Jacobi method and the Gauss-Seidel method
* See "the detailed learning outcomes for PHY 481":"https://dannycab.github.io/phy481msu/learning_goals.html" for more information.

Many of these topics can be included and extended upon in PHY482.



===== Physics Education research and computing in science education =====

The introduction of computational elements in the various courses should be stronly integrated with ongoing research on physics education.

The Physics and Astronomy department at MSU is in a unique position due to its strong research group in physics education, the "PERL group":"http://www.pa.msu.edu/research/physics-education-lab".
This means that it is possible to
develop research motivated curricular changes accompanied by quantitative research, including a proper assessment of various learning outcomes and goals.  There are many interesting challenges here, like
which are the main obstacles when transferring from a classical pen and paper approach to actually have a working program which solves the same (and more general problems). What is a good progression in presenting numerical topics in physics courses? Are there specific mathematical skills we would like our students to have? How do we integrate student-active teaching, how do we develop and test various assessment methods?

The issues include but
are not limited to how well students learn computing, what new
insights students gain about the specific science through computing,
and how students' affective states (e.g., motivation to learn,
computational self-efficacy) are affected by computing . When assessing how well computing can be integrated in core physics courses, various assessments should provide deeper insights into the
integration of computing  in science education in general as well as
provide a structured framework for assessment of our efforts and a
basis for systematic studies of student learning.



===== Advanced computational physics courses =====

Towards the end of undergraduate studies it is useful to offer a course which focuses on more advanced algorithms and presents compiled languages like C++ and Fortran, languages our students will meet in actual research.
Furthemore, such a course, like the present _PHY480 Computational Physics_ offers as well more advanced projects which train the students in actual research, developing more complicated programs and working on larger projects.
The  course could cover
* C++ and/or Fortran programming
* Numerical derivation and integration
* Random numbers and Monte Carlo integration
* Monte Carlo methods in statistical physics
* Quantum Monte Carlo methods
* Linear algebra and eigenvalue problems
* Non-linear equations and roots of polynomials
* Ordinary differential equations
* Partial differential equations
* Parallelization of codes
* High-performance computing aspects and optimization of codes

During the last years, we have witnessed an enhanced background in computing and programming skills among our students. Our students will however always form a heteregeneous group, with often differing competences, experiences and interests. In order to be able to offer a wider spectrum of computational physics courses, the present working group would like to propose courses that can be used in both a major in computational physics, or a Master of Science in computational physics, or a dual degree from the Physics and Astronomy department and the new Computational Mathematics, Science and Engineering (CMSE) department, or just satisfy the scientific interests of our students

In addition to PHY480, we may
consider more advanced (at the graduate level) courses which cover specialized topics.
These could be (presently some of these topics  are covered by PHY905, sections 002 and 003)
  o  Computational quantum mechanics, spanning from Monte Carlo methods to other methods used in atomic, molecular, nuclear, condensed matter and high-energy physics
  o  Computational Statistical mechanics, covering topics spanning from Molecular dynamics to studies of phase transitions, highly relevant for several subdisciplines
  o  Computational Astrophysics and Astronomy
  o  Data analysis and machine learning tailored to physics problems. This course can be jointly taught with the new department of Computational Science.
  o  Additional CMSE courses, see list below.

The CMSE department offers in addition a series "of courses at all levels":"https://cmse.msu.edu/academics/".

===== A possible Physics major in computational physics and a possible MSc in Computational Physics =====

The above advanced courses can form the basis for a MSc in computational physics, as well as, together with
CSME courses, a major in computational physics or a so-called _concentration_ in computational physics.

The following is a suggestion for a major in Computational physics and a Master of Science degree in Computational Physics. We expect this to entail a strong collaboration with the newly established CMSE department.

=== Master of Science in Computational Physics ===

The Master of Science in Computational Physics has a duration of two years, with three semesters  of course work and one semester of thesis work. (discuss whether we should have the flexibility of two semesters of course work and two semesters of thesis work).
o The thesis work is to be conducted with one or more research groups at the Department of Physics and Astronomy. It can also be of a more interdisciplinary character and can be a joint thesis with another department at the College of Natural Science and College of Engineering.
o Core physics courses (these courses should be compulsory)
  * PHY 810, Methods of Theoretical Physics, 3 credits, fall semester
  * PHY 820, Classical Mechanics, 3 credits, fall semester
  * PHY 851, Quantum Mechanics I, 3 credits, fall semester
  * PHY 841, Classical Electrodynamics I, 3 credits, spring semester
  * PHY 831, Statistical Mechanics, 3 credits, fall semester
o Computational Science and Physics courses, select in order to fill up necessary credit requirements.
  * Computational quantum mechanics, spanning from Monte Carlo methods to other methods used in atomic, molecular, nuclear, condensed matter and high-energy physics
  * Computational Statistical mechanics, covering topics spanning from Molecular dynamics to studies of phase transitions, highly relevant for several subdisciplines
  * Computational Astrophysics and Astronomy
  * Data analysis and machine learning tailored to physics problems. This course can be jointly taught with the new department of Computational Science.
  * CMSE 802, Methods in Computational Modeling, 3 credits, spring and fall semesters
  * CMSE 820, Mathematical Foundations of Data Science, 3 credits, spring semester
  * CMSE 821, Numerical Methods for Differential Equations, 3 credits, spring semester
  * CMSE/CSE 822, Parallel Computing, 3 credits, fall semester
  * CMSE 823, Numerical Linear Algebra, I, 3 credits, fall semester


=== Major of Science in Computational Physics ===

The major (or concetration) in Computational Physics replaces all physics laboratory courses with either Computational physics courses and/or CMSE courses.  This point needs further inputs.

===== Links with CMSE and Mathematics courses =====

We would like to propose to establish a working group which studies an eventual  integration and possibly coordination of many of the
abovementioned algorithms in the mathematics courses our physics students take. For example, algorithms from linear algebra play a central role, and with CS201 as background, there is a unique opportunity to enlarge the body of mathematical examples with numerical tools and algorithms. The most likely scenario in the next five to ten years is that our students will be better educated in programming and computations. This should ease the introduction of numerical algorithms and exercises in many of the basic mathematics courses.

With such a background, it is easier for physics teachers, with proper repetitions and adequate material, to introduce numerical exercises and projects in many basic physics courses.




===== Examples on how to Include Computing in Core Physics Courses =====

=== Ordinary differential equations in various courses ===

We assume that our students know how to solve and study systems of
ordinary differential with initial conditions only. Later in this
section we will venture into two-point boundary value problems that
can be studied and solved with eigenvalue solvers.

Let us start with initial value problems and ordinary differential
equations. Such equations appear in a wealth of physics
applications. Typical examples students will encounter are the
classical pendulum in a mechanics course, an RLC circuit in the course on
electromagnetism, the modeling of the Solar system in Astrophysics or Mechanics 
courses and many other cases.  The essential message is that, with
properly scaled equations, students can use essentially the
same algorithms to solve these problems, either starting with
a simple modified Euler algorithm or a Runge-Kutta class of
algorithms or the so-called Verlet class of algorithms, to mention a few.

The idea is that algorithms students develop and use in one course can be
reused in other courses.  This allows  students to make the
relevant abstractions discussed above, opening up for a much wider
range of applicabilities.

Here we look at two familiar cases from
mechanics and electromagnetism, the equations for the classical
pendulum and those for an RLC circuit.  When properly scaled, these
equations are essentially the same. To scale equations,
either in terms of dimensionless variables or appropriate variables,
is an important aspect which allows the students to see the potential
for abstractions and hopefully see how the problems studied in say a
mechanics course can be transferred to other fields.

The classical pendulum with damping and external force as it could
appear in a mechanics course is given by the following equation of
motion for the angle $\theta$ as function of time $t$
!bt
\[
  ml\frac{d^2\theta}{dt^2}+\nu\frac{d\theta}{dt}  +mgsin(\theta)=Acos(\omega t),
\]
!et
where $m$ is its mass, $l$ the length, $\nu$ a damping factor and $A$
the amplitude of an applied external source with frequency
$\omega$. The solution of this type of equations (second-order
differential equations with given initial conditions) is something the
students may encounter in CMSE 201 and Mathematics courses.
With this background, students are already familiar with
the numerical solution and visualization of such equations.
If we now
move to a course on electromagnetism, we encounter almost the same
equation for an RLC circuit, namely
!bt
\[
L\frac{d^2Q}{dt^2}+\frac{Q}{C}+R\frac{dQ}{dt}=Acos(\omega t),
\]
!et
where $L$ is the inductance, $R$ the applied resistance, $Q$ the
time-dependent charge and $C$ the capacitance.

Let us consider first the classical pendulum equations with damping and an
external force and define the scaled velocity $\hat{v}$ as
!bt
\[
   \frac{d\theta}{d\hat{t}} =\hat{v},
\]
!et
where we have defined a dimensionless time variable $\hat{t}$. With
the equation for the velocity we can rewrite the second-order
differential in terms of two coupled first-order differential
equations where the second equation represents the acceleration
!bt
\[
   \frac{d\hat{v}}{d\hat{t}} =Acos(\hat{\omega} \hat{t})-\hat{v}\xi-\sin(\theta).
\]
!et
We have scaled the  equations with $\omega_0=\sqrt{g/l}$,
$\hat{t}=\omega_0 t$ and $\xi = mg/\omega_0\nu$. The frequency
$\omega_0$ defines a so-called natural frequency defined by the
gravitational acceleration $g$ and the length of the pendulum $l$. The
frequency $\hat{\omega}= \omega/\omega_0$.  In a similar way, our RLC
circuit can now be rewritten in terms of two coupled first-order
differential equations,
!bt
\[
   \frac{dQ}{d\hat{t}} =\hat{I},
\]
!et
and
!bt
\[
   \frac{d\hat{I}}{d\hat{t}} =Acos(\hat{\omega} \hat{t})-\hat{I}\xi-Q,
\]
!et
with $\omega_0=1/\sqrt{LC}$, $\hat{t}=\omega_0 t$ and $\xi =
CR\omega_0$. Here we see that the natural frequency is defined in
terms of the physical parameters $L$ and $C$.

The equations are essentially the same, the main differences reside in
the different scaling constants and the introduction of a non-linear
term for the angle $\theta$ in the pendulum equation. The differential
solver the students end up writing in the mechanics course (which
comes normally before the course on electromagnetism) can then be
reused in the electromagnetism course, with a great potential for
further abstraction.

=== Two-point boundary value problem ===

Let us now move to another frequently encountered problem in several
physics courses, namely that of a two-point boundary value problem. In
the examples below we will see again that if the equations are
properly scaled, we can reuse the same algorithm for solving different
physics problems. Here we will start with the equations for a buckling
beam (a case which can be found in a mechanics course or a course on
mathematical methods in physics). Thereafter, with a simple change of
variables and constants, the same problem can be used to study a
quantum mechanical particle confined to move in an infinite potential
well.  By simply changing the diagonal matrix elements of the
discretized differential equation problem, we can study particles that
move in a harmonic oscillator potential or other types of
quantum-mechanical one-body or selected two-body problems.  With
slight modifications to the matrix that results from the
discretization of a second derivative, we can study Poisson's equation
in one dimension, a problem of relevance in
electromagnetism.

Let us start with the buckling beam. This is a two-point boundary
value problem
!bt
\[
R \frac{d^2 u(x)}{dx^2} = -F u(x),
\]
!et
where $u(x)$ is the vertical displacement, $R$ is a material specific
constant, $F$ is the applied force and $x \in [0,L]$ with $u(0)=u(L)=0$.
We scale the equation with $x = \rho L$ and $\rho \in [0,1]$ and get
(note that we change from $u(x)$ to $v(\rho)$)
!bt
\[
\frac{d^2 v(\rho)}{dx^2} +K v(\rho)=0,
\]
!et
which is, when discretized (see below), nothing but a standard eigenvalue problem with $K=
FL^2/R$. Here we can assume that either the force $F$ or the material
specific rigidity $R$ are unknown.  If we replace $R=-\hbar^2/2m$ and
$-F=\lambda$, we have the quantum mechanical variant for a particle
moving in a well with infinite walls at the endpoints.  The way to
solve these equations numerically is to discretize the second
derivative and the right hand side as
!bt
\[
    -\frac{v_{i+1} -2v_i +v_{i-i}}{h^2}=\lambda v_i,
\]
!et
with $i=1,2,\dots, n$. Here $h$ is the step size which is defined by
the number of integration (or mesh) points.  We need to add to this
system the two boundary conditions $v(0) =v_0$ and $v(1) = v_{n+1}$,
although they are not needed in the solution of the equations since
their values are known.  For all integration points $i=1,2,\dots, n$
the set of equations to solve result in a so-called tridiagonal
Toeplitz matrix ( a special case arising from the discretized second
derivative)
!bt
\[
    \mathbf{A} = \frac{1}{h^2}\begin{bmatrix}
                          2 & -1 &  &   &  & \\
                          -1 & 2 & -1 & & & \\
                           & -1 & 2 & -1 & &  \\
                           & \dots   & \dots &\dots   &\dots & \dots \\
                           &   &  &-1  &2& -1 \\
                           &    &  &   &-1 & 2 \\
                      \end{bmatrix}
\]
!et
and with the corresponding vectors $\mathbf{v} = (v_1, v_2,
\dots,v_n)^T$ allows us to rewrite the differential equation as a
standard eigenvalue problem
!bt
\[
   \mathbf{A}\mathbf{v} = \lambda\mathbf{v}.
\]
!et
The tridiagonal Toeplitz matrix has analytical eigenpairs,
providing us thereby with an invaluable check on the equations to be
solved.

If we stay with quantum mechanical one-body problems (or
special interacting two-body problems) adding a potential along the
diagonal elements allows us to reuse this problem for many types of physics
cases.  To see this, let us assume we are interested in the solution
of the radial part of Schr\"odinger's equation for one electron. This
equation reads
!bt
\[
  -\frac{\hbar^2}{2 m} \left ( \frac{1}{r^2} \frac{d}{dr} r^2
  \frac{d}{dr} - \frac{l (l + 1)}{r^2} \right )R(r)
     + V(r) R(r) = E R(r).
\]
!et
Suppose in our case $V(r)$ is the harmonic oscillator potential
$(1/2)kr^2$ with $k=m\omega^2$ and $E$ is the energy of the harmonic
oscillator in three dimensions.  The oscillator frequency is $\omega$
and the energies are
!bt
\[
E_{nl}=  \hbar \omega \left(2n+l+\frac{3}{2}\right),
\]
!et
with $n=0,1,2,\dots$ and $l=0,1,2,\dots$.

Since we have made a transformation to spherical coordinates it means
that $r\in [0,\infty)$. The quantum number $l$ is the orbital momentum
  of the electron.  In order to find analytical solutions for this
  problem, we would substitute $R(r) = (1/r) u(r)$ (which gives
  $u(0)=u(\infty)=0$ and thereby easier boundary conditions) and
  obtain
!bt
\[
  -\frac{\hbar^2}{2 m} \frac{d^2}{dr^2} u(r)
       + \left ( V(r) + \frac{l (l + 1)}{r^2}\frac{\hbar^2}{2 m}
                                    \right ) u(r)  = E u(r) .
\]
!et
The boundary conditions are $u(0)=0$ and $u(\infty)=0$.

In order to scale the equations, we introduce a dimensionless variable $\rho = (1/\alpha) r$
where $\alpha$ is a constant with dimension length and get
!bt
\[
  -\frac{\hbar^2}{2 m \alpha^2} \frac{d^2}{d\rho^2} v(\rho)
       + \left ( V(\rho) + \frac{l (l + 1)}{\rho^2}
         \frac{\hbar^2}{2 m\alpha^2} \right ) v(\rho)  = E v(\rho) .
\]
!et
Let us choose $l=0$ for the mere sake of simplicity.
Inserting $V(\rho) = (1/2) k \alpha^2\rho^2$ we end up with
!bt
\[
  -\frac{\hbar^2}{2 m \alpha^2} \frac{d^2}{d\rho^2} v(\rho)
       + \frac{k}{2} \alpha^2\rho^2v(\rho)  = E v(\rho).
\]
!et
We multiply thereafter with $2m\alpha^2/\hbar^2$ on both sides and obtain
!bt
\[
  -\frac{d^2}{d\rho^2} v(\rho)
       + \frac{mk}{\hbar^2} \alpha^4\rho^2v(\rho)  = \frac{2m\alpha^2}{\hbar^2}E v(\rho) .
\]
!et
A natural length scale comes out automatically when scaling. To see this, since $\alpha$ is constant we are left to determine, 
we determine $\alpha$ by requiring that
!bt
\[
\frac{mk}{\hbar^2} \alpha^4 = 1.
\]
!et
This defines a natural length scale in terms of the various physical
constants that determine the equation.  The final expression, inserting $k=m\omega^2$ is
!bt
\[
\alpha = \left(\frac{\hbar}{m\omega}\right)^{1/2}.
\]
!et
If we were to replace the harmonic oscillator potential with the
attractive Coulomb interaction from the hydrogen atom, the  parameter $\alpha$ would equal the Bohr
radius $a_0$.  This way students see the general properties of a
two-point boundary value problem and can reuse the code they developed
for a mechanics course to the subsequent quantum mechanical course.

Defining
!bt
\[
\lambda = \frac{2m\alpha^2}{\hbar^2}E,
\]
!et
we can rewrite Schroedinger's equation as
!bt
\[
  -\frac{d^2}{d\rho^2} v(\rho) + \rho^2v(\rho)  = \lambda v(\rho) .
\]
!et
This is similar to the equation for a buckling beam, except for the
potential term.  In three dimensions with our scaling, the eigenvalues for $l=0$ are
$\lambda_0=3,\lambda_1=7,\lambda_2=11,\dots .$

If we  define first the diagonal matrix element
!bt
\[
   d_i=\frac{2}{h^2}+V_i,
\]
!et
and the non-diagonal matrix element
!bt
\[
   e_i=-\frac{1}{h^2},
\]
!et
we can rewrite the Schr\"oedinger equation as
!bt
\[
d_iu_i+e_{i-1}v_{i-1}+e_{i+1}v_{i+1}  = \lambda v_i,
\]
!et
where $v_i$ is unknown and $i=1,2,\dots, n$. We can reformulate the
latter equation as a matrix eigenvalue problem
!bt
\[
    \begin{bmatrix} d_1 & e_1 & 0   & 0    & \dots  &0     & 0 \\
                                e_1 & d_2 & e_2 & 0    & \dots  &0     &0 \\
                                0   & e_2 & d_3 & e_3  &0       &\dots & 0\\
                                \dots  & \dots & \dots & \dots  &\dots      &\dots & \dots\\
                                0   & \dots & \dots & \dots  &\dots       &d_{n-1} & e_{n-1}\\
                                0   & \dots & \dots & \dots  &\dots       &e_{n-1} & d_{n}
             \end{bmatrix}      \begin{bmatrix} v_{1} \\
                                                              v_{2} \\
                                                              \dots\\ \dots\\ \dots\\
                                                              v_{n}
             \end{bmatrix}=\lambda \begin{bmatrix}{c} v_{1} \\
                                                              v_{2} \\
                                                              \dots\\ \dots\\ \dots\\
                                                              v_{n}
             \end{bmatrix}
\]
!et
or if we wish to be more detailed, we can write the tridiagonal matrix as
!bt
\[
    \begin{bmatrix} \frac{2}{h^2}+V_1 & -\frac{1}{h^2} & 0   & 0    & \dots  &0     & 0 \\
                                -\frac{1}{h^2} & \frac{2}{h^2}+V_2 & -\frac{1}{h^2} & 0    & \dots  &0     &0 \\
                                0   & -\frac{1}{h^2} & \frac{2}{h^2}+V_3 & -\frac{1}{h^2}  &0       &\dots & 0\\
                                \dots  & \dots & \dots & \dots  &\dots      &\dots & \dots\\
                                0   & \dots & \dots & \dots  &\dots       &\frac{2}{h^2}+V_{n-1} & -\frac{1}{h^2}\\
                                0   & \dots & \dots & \dots  &\dots       &-\frac{1}{h^2} & \frac{2}{h^2}+V_{n}
             \end{bmatrix}.
\]
!et
The following Python code sets up the matrix to diagonalize by defining
the minimun and maximum values of $r$ with a maximum value of
integration points. It plots the eigenfunctions of the three lowest
eigenstates (click on evaluate and run the program!).
!bc pyscpro
#Program which solves the one-particle Schrodinger equation
#for a potential specified in function
#potential().

from  matplotlib import pyplot as plt
import numpy as np
#Function for initialization of parameters
def initialize():
    RMin = 0.0
    RMax = 10.0
    lOrbital = 0
    Dim = 400
    return RMin, RMax, lOrbital, Dim
# Harmonic oscillator potential
def potential(r):
    return r*r

#Get the boundary, orbital momentum and number of integration points
RMin, RMax, lOrbital, Dim = initialize()

#Initialize constants
Step    = RMax/(Dim)
DiagConst = 2.0/ (Step*Step)
NondiagConst =  -1.0 / (Step*Step)
OrbitalFactor = lOrbital * (lOrbital + 1.0)

#Calculate array of potential values
v = np.zeros(Dim)
r = np.linspace(RMin,RMax,Dim)
for i in range(Dim):
    r[i] = RMin + (i+1) * Step;
    v[i] = potential(r[i]) + OrbitalFactor/(r[i]*r[i]);

#Setting up a tridiagonal matrix and finding eigenvectors and eigenvalues
Matrix = np.zeros((Dim,Dim))
Matrix[0,0] = DiagConst + v[0];
Matrix[0,1] = NondiagConst;
for i in xrange(1,Dim-1):
    Matrix[i,i-1]  = NondiagConst;
    Matrix[i,i]    = DiagConst + v[i];
    Matrix[i,i+1]  = NondiagConst;
Matrix[Dim-1,Dim-2] = NondiagConst;
Matrix[Dim-1,Dim-1] = DiagConst + v[Dim-1];
# diagonalize and obtain eigenvalues, not necessarily sorted
EigValues, EigVectors = np.linalg.eig(Matrix)
# sort eigenvectors and eigenvalues
permute = EigValues.argsort()
EigValues = EigValues[permute]
EigVectors = EigVectors[:,permute]
# now plot the results for the three lowest lying eigenstates
for i in range(3):
    print(EigValues[i])
FirstEigvector = EigVectors[:,0]
SecondEigvector = EigVectors[:,1]
ThirdEigvector = EigVectors[:,2]
plt.plot(r, FirstEigvector**2 ,'b-',r, SecondEigvector**2 ,'g-',r, ThirdEigvector**2 ,'r-')
plt.axis([0,5.0,0.0, 0.025])
plt.xlabel(r'$r$')
plt.ylabel(r'Radial probability $r^2|R(r)|^2$')
plt.title(r'Radial probability distributions for three lowest-lying states')
plt.savefig('eigenvector.pdf')
plt.show()
!ec

The last example shows the potential of combining numerical algorithms with analytical results (or eventually symbolic calculations), allowing thereby students to test their physics understanding. One can easily switch to other potentials by simply redefining the potential function. For example, a finite box potential can easily be defined as
!bc  pycod
# Finite depth and range box potential, with strength V and range a
def potential(r):
    if r >= 0.0 and r <= 10.0:
        V = -0.05
    else:
        V =0.0
    return V
!ec
Thereafter, the students can explore the role of the potential depth
and the range of the potential. Analyzing the eigenvectors gives
additional information about the spatial degrees of freedom in terms
of different potentials.  The possibility to visualize the results immediately, aids in providing students with a deeper understanding of the relevant physics.

This example contains also many of the
computing learning outcomes we discussed above, in addition to those
related to the physics of a particular system. We see that, by proper
scaling, the students can make further abstractions and explore other
physics cases easily where no analytical solutions are known. With
unit testing and analytical results they can validate and verify their
algorithms.

The above example allows the student to test the mathematical error of
the algorithm for the eigenvalue solver by simply changing the number
of integration points. The students get trained to develop an
understanding of the error analysis and where things can go wrong. The
algorithm can be tailored to any kind of one-particle problem used in
quantum mechanics.

A simple rewrite allows for the reuse in linear algebra problems for
solution of say Poisson's equation in electromagnetism, or the
diffusion equation in one dimension. To see this and how the same matrix can be used in a course in electromagnetism, let us consider
Poisson's equation.
We assume that
the electrostatic potential $\Phi$ is generated by a localized charge
distribution $\rho (\mathbf{r})$.   In three dimensions
the pertinent equation reads
!bt
\[
\nabla^2 \Phi = -4\pi \rho (\mathbf{r}).
\]
!et
With a spherically symmetric potential $\Phi$ and charge distribution $\rho (\mathbf{r})$ and using spherical coordinates,  the relevant
equation to solve
simplifies to a one-dimensional equation in $r$, namely
!bt
\[
\frac{1}{r^2}\frac{d}{dr}\left(r^2\frac{d\Phi}{dr}\right) = -4\pi \rho(r),
\]
!et
which can be rewritten via a substitution $\Phi(r)= \phi(r)/r$ as
!bt
\[
\frac{d^2\phi}{dr^2}= -4\pi r\rho(r).
\]
!et
The inhomogeneous term $f$ or source term is given by the charge distribution
$\rho$  multiplied by $r$ and the constant $-4\pi$.

We can  rewrite this equation by letting $\phi\rightarrow u$ and
$r\rightarrow x$.  Scaling again the equations and replacing the right hand side with a function $f(x)$, we can rewrite the
equation as
!bt
\[
-u''(x) = f(x).
\]
!et
Our scaling gives us again $x\in [0,1]$ and the two-point boundary value problem
with $u(0)=u(1)=0$. With $n+1$ integration points and
the step length defined as $h=1/(n)$ and replacing the continuous function $u$ with its discretized version $v$, we get
the following equation
!bt
\begin{equation*}
   -\frac{v_{i+1}+v_{i-1}-2v_i}{h^2} = f_i  \hspace{0.5cm} \mathrm{for} \hspace{0.1cm} i=1,\dots, n,
\end{equation*}
!et
where $f_i=f(x_i)$.
Bringing up again the tridiagonal Toeplitz matrix,
!bt
\[
    \mathbf{A} = \frac{1}{h^2}\begin{bmatrix}
                           2& -1& 0 &\dots   & \dots &0 \\
                           -1 & 2 & -1 &0 &\dots &\dots \\
                           0&-1 &2 & -1 & 0 & \dots \\
                           & \dots   & \dots &\dots   &\dots & \dots \\
                           0&\dots   &  &-1 &2& -1 \\
                           0&\dots    &  & 0  &-1 & 2 \\
                      \end{bmatrix},
\]
!et
our problem becomes now a classical linear algebra problem
!bt
\[
\mathbf{A}\mathbf{v}=\mathbf{f},
\]
!et
with the unknown function $\mathbf{v}$. Using standard LU
decomposition algorithms (here one can use
the so-called Thomas algorithm which reduces the number of floating
point operations to $O(n)$) one can easily find the solution to this
problem.

These examples demonstrate how one can, with a discretized second
derivative, solve physics problems that arise in different
undergraduate courses using standard linear algebra and eigenvalue
algorithms and ordinary differential equations, allowing thereby
teachers to focus on the interesting physics. Many of these problems
can easily be linked up with ongoing research. This opens up for many
interesting perspectives in physics education. We can bring in at a
much earlier stage in our education basic research elements and
perhaps even link with ongoing research during the first year of
undergraduate studies.

Instead of focusing on tricks and mathematical manipulations to solve
the continuous problems for those few case where an analytical
solution can be found, the discretization of the continuous problem
opens up for studies of many more interesting and realistic problems.
However, we have seen that in order to verify and validate our codes,
the existence of analytical solutions offer us an invaluable test of
our algorithms and programs. The analytical results can either be
included explicitely or via symbolic software like Python's Sympy package.
Thus, computing stands indeed for solving scientific problems using
all possible tools, including symbolic computing, computers and
numerical algorithms, numerical experiments (as well as real
experiments if possible) and analytical paper and pencil solutions.



The benefits are many, in particular it allows us to make our research
more visible in early undergraduate physics courses, enhancing
research-based teaching with the possibility to focus more on
understanding and increased insight.  It gives also our candidates the
skills and abilities that are requested by society at large, both from
the private and the public sectors. With computing, we emphasize a broader and
more up-to-date education with a problem-based orientation, often
requested by potential employers.  Furthermore, there are clear
indications that a discussion of computing across disciplines results in an increased
impetus for broad cooperation in teaching and a broader focus on university pedagogical topics.

